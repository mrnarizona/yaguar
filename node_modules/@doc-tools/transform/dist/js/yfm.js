(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
})((function () { 'use strict';

  var getRootNodePolyfill = {exports: {}};

  (function (module) {

  	// Node getRootNode(optional GetRootNodeOptions options);

  	/**
  	 * Returns the context object’s shadow-including root if options’s composed is true.
  	 * Returns the context object’s root otherwise.
  	 *
  	 * The root of an object is itself, if its parent is null, or else it is the root of its parent.
  	 *
  	 * The shadow-including root of an object is its root’s host’s shadow-including root,
  	 * if the object’s root is a shadow root, and its root otherwise.
  	 *
  	 * https://dom.spec.whatwg.org/#dom-node-getrootnode
  	 *
  	 * @memberof Node.prototype
  	 * @param {!Object} [opt = {}] - Options.
  	 * @param {!boolean} [opt.composed] - See above description.
  	 * @returns {!Node} The root node.
  	 */
  	function getRootNode(opt) {
  	  var composed = typeof opt === 'object' && Boolean(opt.composed);

  	  return composed ? getShadowIncludingRoot(this) : getRoot(this);
  	}

  	function getShadowIncludingRoot(node) {
  	  var root = getRoot(node);

  	  if (isShadowRoot(root)) {
  	    return getShadowIncludingRoot(root.host);
  	  }

  	  return root;
  	}

  	function getRoot(node) {
  	  if (node.parentNode != null) {
  	    return getRoot(node.parentNode);
  	  }

  	  return node;
  	}

  	function isShadowRoot(node) {
  	  return node.nodeName === '#document-fragment' && node.constructor.name === 'ShadowRoot';
  	}

  	if (module.exports) {
  	  module.exports = getRootNode;
  	}
  } (getRootNodePolyfill));

  var getRootNode = getRootNodePolyfill.exports;

  if (typeof document !== 'undefined') {
    // matches polyfill for old edge
    (function (e) {
      var matches = e.matches || e.matchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector;

      if (matches) {
        e.matches = e.matchesSelector = matches;
      } else {
        e.matches = e.matchesSelector = function matches(selector) {
          var rootNode = e.getRootNode ? e.getRootNode() : getRootNode.call(e);
          var matches = rootNode.querySelectorAll(selector);
          var th = this;
          return Array.prototype.some.call(matches, function (e) {
            return e === th;
          });
        };
      }
    })(Element.prototype);
  }

  const getEventTarget = (event) => {
      const path = event.composedPath();
      return Array.isArray(path) && path.length > 0 ? path[0] : event.target;
  };
  const isCustom = (event) => {
      const target = getEventTarget(event);
      return !target || !target.matches;
  };

  const Selector$2 = {
      TABS: '.yfm .yfm-tabs',
      TAB_LIST: '.yfm .yfm-tab-list',
      TAB: '.yfm .yfm-tab',
      TAB_PANEL: '.yfm .yfm-tab-panel',
  };
  const ClassName$1 = {
      ACTIVE: 'active',
  };
  function selectTab(element) {
      const parentNode = element.parentNode;
      if (!parentNode ||
          !parentNode.matches(Selector$2.TAB_LIST) ||
          !parentNode.parentNode ||
          !parentNode.parentNode.matches(Selector$2.TABS) ||
          element.classList.contains(ClassName$1.ACTIVE)) {
          return;
      }
      const tab = element;
      const tabList = tab.parentNode;
      const tabsContainer = tabList === null || tabList === void 0 ? void 0 : tabList.parentNode;
      const allTabs = Array.from((tabsContainer === null || tabsContainer === void 0 ? void 0 : tabsContainer.querySelectorAll(Selector$2.TAB)) || []);
      const allPanels = Array.from((tabsContainer === null || tabsContainer === void 0 ? void 0 : tabsContainer.querySelectorAll(Selector$2.TAB_PANEL)) || []);
      const targetIndex = allTabs.indexOf(tab);
      for (let i = 0; i < allTabs.length; i++) {
          const tab = allTabs[i];
          const panel = allPanels[i];
          if (i === targetIndex) {
              tab.classList.toggle(ClassName$1.ACTIVE, true);
              tab.setAttribute('aria-selected', 'true');
              tab.setAttribute('tabindex', '0');
              panel.classList.toggle(ClassName$1.ACTIVE, true);
          }
          else {
              tab.classList.toggle(ClassName$1.ACTIVE, false);
              tab.setAttribute('aria-selected', 'false');
              tab.setAttribute('tabindex', '-1');
              panel.classList.toggle(ClassName$1.ACTIVE, false);
          }
      }
  }
  if (typeof document !== 'undefined') {
      document.addEventListener('click', (event) => {
          const target = getEventTarget(event);
          if (isCustom(event) || !target.matches(Selector$2.TAB)) {
              return;
          }
          selectTab(target);
      });
  }

  const BUTTON_SELECTOR = '.yfm-clipboard-button';
  function copyToClipboard(text) {
      if (!text) {
          return Promise.resolve();
      }
      if (navigator.clipboard && typeof navigator.clipboard.writeText) {
          return navigator.clipboard.writeText(text);
      }
      const textarea = document.createElement('textarea');
      textarea.setAttribute('style', 'position: absolute; left: 1000%');
      textarea.textContent = text;
      document.body.append(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      return Promise.resolve();
  }
  function notifySuccess(svgButton) {
      if (!svgButton) {
          return;
      }
      const id = svgButton.getAttribute('data-animation');
      // @ts-expect-error
      const icon = svgButton.getRootNode().getElementById(`visibileAnimation-${id}`);
      if (!icon) {
          return;
      }
      icon.beginElement();
  }
  if (typeof document !== 'undefined') {
      document.addEventListener('click', (event) => {
          const target = getEventTarget(event);
          if (isCustom(event) || !target.matches(BUTTON_SELECTOR)) {
              return;
          }
          const parent = target.parentNode;
          if (!parent) {
              return;
          }
          const code = parent.querySelector('pre code');
          if (!code) {
              return;
          }
          copyToClipboard(code.innerText).then(() => {
              notifySuccess(parent.querySelector('.yfm-clipboard-button'));
          });
      });
  }

  const Selector$1 = {
      CUT: '.yfm .yfm-cut',
      TITLE: '.yfm .yfm-cut-title',
      CONTENT: '.yfm .yfm-cut-content',
  };
  const ClassName = {
      OPEN: 'open',
  };
  function toggleCut(element) {
      const cutNode = element.parentNode;
      if (!(cutNode instanceof HTMLElement)) {
          return;
      }
      cutNode.classList.toggle(ClassName.OPEN);
  }
  function matchTitle(target) {
      var _a;
      if (!(target instanceof HTMLElement)) {
          return false;
      }
      return (_a = target === null || target === void 0 ? void 0 : target.matches) === null || _a === void 0 ? void 0 : _a.call(target, Selector$1.TITLE);
  }
  function findTitleInPath(event) {
      var _a;
      const target = getEventTarget(event);
      if (matchTitle(target)) {
          return target;
      }
      const path = (_a = event.composedPath) === null || _a === void 0 ? void 0 : _a.call(event);
      return path === null || path === void 0 ? void 0 : path.find(matchTitle);
  }
  if (typeof document !== 'undefined') {
      document.addEventListener('click', (event) => {
          if (isCustom(event)) {
              return;
          }
          const title = findTitleInPath(event);
          if (!title) {
              return;
          }
          toggleCut(title);
      });
  }

  const Selector = {
      TITLE: '.yfm .yfm-term_title',
      CONTENT: '.yfm .yfm-term_dfn',
  };
  const openClass = 'open';
  const openDefinitionClass = Selector.CONTENT.replace(/\./g, '') + ' ' + openClass;
  let isListenerNeeded = true;
  function createDefinitionElement(termElement) {
      var _a;
      const termKey = termElement.getAttribute('term-key');
      const definitionTemplate = document.getElementById(`${termKey}_template`);
      const definitionElement = definitionTemplate === null || definitionTemplate === void 0 ? void 0 : definitionTemplate.content.cloneNode(true).firstChild;
      (_a = definitionTemplate === null || definitionTemplate === void 0 ? void 0 : definitionTemplate.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(definitionElement);
      definitionTemplate.remove();
      return definitionElement;
  }
  function setDefinitionId(definitionElement, termElement) {
      const termId = termElement.getAttribute('id') || Math.random().toString(36).substr(2, 8);
      definitionElement === null || definitionElement === void 0 ? void 0 : definitionElement.setAttribute('term-id', termId);
  }
  function setDefinitionPosition(definitionElement, termElement) {
      const { x: termX, y: termY, right: termRight, left: termLeft, width: termWidth, height: termHeight, } = termElement.getBoundingClientRect();
      const termParent = termParentElement(termElement);
      if (!termParent) {
          return;
      }
      const { right: termParentRight, left: termParentLeft } = termParent.getBoundingClientRect();
      if ((termParentRight < termLeft || termParentLeft > termRight) && !isListenerNeeded) {
          closeDefinition(definitionElement);
          return;
      }
      if (isListenerNeeded && termParent) {
          termParent.addEventListener('scroll', termOnResize);
          isListenerNeeded = false;
      }
      const relativeX = Number(definitionElement.getAttribute('relativeX'));
      const relativeY = Number(definitionElement.getAttribute('relativeY'));
      if (relativeX === termX && relativeY === termY) {
          return;
      }
      definitionElement.setAttribute('relativeX', String(termX));
      definitionElement.setAttribute('relativeY', String(termY));
      const offsetTop = termHeight + 5;
      const definitionParent = definitionElement.parentElement;
      if (!definitionParent) {
          return;
      }
      const { width: definitionWidth } = definitionElement.getBoundingClientRect();
      const { left: definitionParentLeft } = definitionParent.getBoundingClientRect();
      // If definition not fit document change base alignment
      const definitionRightCoordinate = definitionWidth + Number(getCoords(termElement).left);
      const fitDefinitionDocument = document.body.clientWidth > definitionRightCoordinate ? 0 : definitionWidth - termWidth;
      const customHeaderTop = getCoords(definitionParent).top - definitionParent.offsetTop;
      definitionElement.style.top =
          Number(getCoords(termElement).top + offsetTop - customHeaderTop) + 'px';
      definitionElement.style.left =
          Number(getCoords(termElement).left -
              definitionParentLeft +
              definitionParent.offsetLeft -
              fitDefinitionDocument) + 'px';
  }
  function termOnResize() {
      const openDefinition = document.getElementsByClassName(openDefinitionClass)[0];
      if (!openDefinition) {
          return;
      }
      const termId = openDefinition.getAttribute('term-id') || '';
      const termElement = document.getElementById(termId);
      if (!termElement) {
          return;
      }
      setDefinitionPosition(openDefinition, termElement);
  }
  function termParentElement(term) {
      if (!term) {
          return null;
      }
      const closestScrollableParent = term.closest('table') || term.closest('code');
      return closestScrollableParent || term.parentElement;
  }
  function closeDefinition(definition) {
      definition.classList.remove(openClass);
      const termId = definition.getAttribute('term-id') || '';
      const termParent = termParentElement(document.getElementById(termId));
      if (!termParent) {
          return;
      }
      termParent.removeEventListener('scroll', termOnResize);
      isListenerNeeded = true;
  }
  function getCoords(elem) {
      const box = elem.getBoundingClientRect();
      const body = document.body;
      const docEl = document.documentElement;
      const scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
      const scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
      const clientTop = docEl.clientTop || body.clientTop || 0;
      const clientLeft = docEl.clientLeft || body.clientLeft || 0;
      const top = box.top + scrollTop - clientTop;
      const left = box.left + scrollLeft - clientLeft;
      return { top: Math.round(top), left: Math.round(left) };
  }

  if (typeof document !== 'undefined') {
      document.addEventListener('click', (event) => {
          const openDefinition = document.getElementsByClassName(openDefinitionClass)[0];
          const target = getEventTarget(event);
          const termId = target.getAttribute('id');
          const termKey = target.getAttribute('term-key');
          let definitionElement = document.getElementById(termKey + '_element');
          if (termKey && !definitionElement) {
              definitionElement = createDefinitionElement(target);
          }
          const isSameTerm = openDefinition && termId === openDefinition.getAttribute('term-id');
          if (isSameTerm) {
              closeDefinition(openDefinition);
              return;
          }
          const isTargetDefinitionContent = target.closest([Selector.CONTENT.replace(' ', ''), openClass].join('.'));
          if (openDefinition && !isTargetDefinitionContent) {
              closeDefinition(openDefinition);
          }
          if (isCustom(event) || !target.matches(Selector.TITLE) || !definitionElement) {
              return;
          }
          setDefinitionId(definitionElement, target);
          setDefinitionPosition(definitionElement, target);
          definitionElement.classList.toggle(openClass);
      });
      document.addEventListener('keydown', (event) => {
          const openDefinition = document.getElementsByClassName(openDefinitionClass)[0];
          if (event.key === 'Escape' && openDefinition) {
              closeDefinition(openDefinition);
          }
      });
      window.addEventListener('resize', () => {
          const openDefinition = document.getElementsByClassName(openDefinitionClass)[0];
          if (!openDefinition) {
              return;
          }
          const termId = openDefinition.getAttribute('term-id') || '';
          const termElement = document.getElementById(termId);
          if (!termElement) {
              openDefinition.classList.toggle(openClass);
              return;
          }
          setDefinitionPosition(openDefinition, termElement);
      });
  }

}));
//# sourceMappingURL=yfm.js.map
