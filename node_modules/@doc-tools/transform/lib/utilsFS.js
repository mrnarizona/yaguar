"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSinglePageAnchorId = exports.getFullIncludePath = exports.getFileTokens = exports.resolveRelativePath = exports.isFileExists = void 0;
const lodash_1 = __importDefault(require("lodash"));
const fs_1 = require("fs");
const path_1 = require("path");
const liquid_1 = __importDefault(require("./liquid"));
const filesCache = {};
function isFileExists(file) {
    try {
        const stats = (0, fs_1.statSync)(file);
        return stats.isFile();
    }
    catch (e) {
        return false;
    }
}
exports.isFileExists = isFileExists;
function resolveRelativePath(fromPath, relativePath) {
    const { dir: fromDir } = (0, path_1.parse)(fromPath);
    return (0, path_1.resolve)(fromDir, relativePath);
}
exports.resolveRelativePath = resolveRelativePath;
function getFileTokens(path, state, options) {
    const { getVarsPerFile, vars, disableLiquid, disableLint, lintMarkdown, disableTitleRefSubstitution, disableCircularError, inheritVars = true, } = options;
    let content;
    const builtVars = (getVarsPerFile && !inheritVars ? getVarsPerFile(path) : vars) || {};
    if (filesCache[path]) {
        content = filesCache[path];
    }
    else {
        content = (0, fs_1.readFileSync)(path, 'utf8');
        filesCache[path] = content;
    }
    let sourceMap;
    if (!disableLiquid) {
        const liquidResult = (0, liquid_1.default)(content, builtVars, path, { withSourceMap: true });
        content = liquidResult.output;
        sourceMap = liquidResult.sourceMap;
    }
    if (!disableLint && lintMarkdown) {
        lintMarkdown({
            input: content,
            path,
            sourceMap,
        });
    }
    const meta = state.md.meta;
    const tokens = state.md.parse(content, Object.assign(Object.assign({}, state.env), { path,
        disableTitleRefSubstitution,
        disableCircularError }));
    state.md.meta = meta;
    return tokens;
}
exports.getFileTokens = getFileTokens;
const getFullIncludePath = (includePath, root, path) => {
    let fullIncludePath;
    if (includePath.startsWith(path_1.sep)) {
        fullIncludePath = (0, path_1.join)(root, includePath);
    }
    else {
        fullIncludePath = resolveRelativePath(path, includePath);
    }
    return fullIncludePath;
};
exports.getFullIncludePath = getFullIncludePath;
function getSinglePageAnchorId(args) {
    const { root, currentPath, pathname, hash } = args;
    let resultAnchor = currentPath;
    if (pathname) {
        resultAnchor = resolveRelativePath(currentPath, pathname);
    }
    resultAnchor = resultAnchor
        .replace(root, '')
        .replace(/\.(md|ya?ml|html)$/i, '')
        .replace(new RegExp(lodash_1.default.escapeRegExp(path_1.sep), 'gi'), '_');
    if (hash) {
        resultAnchor = resultAnchor + '_' + hash.slice(1);
    }
    return `#${resultAnchor}`;
}
exports.getSinglePageAnchorId = getSinglePageAnchorId;
//# sourceMappingURL=utilsFS.js.map